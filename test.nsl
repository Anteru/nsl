struct TransformationMatrices
{
	uint applyOffset[3];
	matrix4x4 matrices[3];
	float4 offset[3];
}

struct TransformInfo
{
	uint pointsToTransform;
	TransformationMatrices transforms[32];
}

float4 inputPositions[32];
float4 outputPositions[32];

export function AddTwoIntegers(int a, int b) -> int
{
	return a + b;
}

int global_a;

export function AddToGlobal(int a) -> int
{
	return a + global_a;
}

int global_array[2];

export function AddToGlobalArray (int a, int index) -> int
{
	return a + global_array[index];
}

export function AddToArgumentArray (int a, int i, int arr[2]) -> void {
	arr [i] += a;
}

export function PostfixAdd(int a) -> int {
	return a++;
}

export function AssignToVectorUsingArrayAccess(float4 v, int i, float f) -> float4 {
	v[i] = f;
	return v;
}

export function vectorAccessUsingIndex(float4 v, int i) -> float {
	return v[i];
}

export function vectorAccessUsingSwizzle(float4 v) -> float {
	return v.y;
}

export function matrixAssignVectorToRow(float4x4 m, float4 v) -> float4x4 {
	m[1] = v;
	return m;
}

export function matrixAccessUsingArrayAccess(float4x4 f, int i, int j) -> float {
	return f[i][j];
}

export function matrixAssignUsingArrayAccess(float4x4 f, int i, int j, float v) -> float {
	f[i][j] = v;
	return f;
}

struct test_struct
{
	int a;
	int b;
}

export function assignToStructMember(test_struct s, int i) -> test_struct {
	s.a = i;
	return s;
}

export function branchIfElseIfElse(int a) -> int {
    if(a < 5) { return 0; }
	else if (a > 5) { return 1; }
	else { return -1; }
}

export function matrixMatrixAdd(float4x4 a, float4x4 b) -> float4x4 {
	return a + b;
}

export function matrixMatrixMul(float4x4 a, float4x4 b) -> float4x4 {
	return a * b;
}

export function simpleLoop(float f, int l) -> float {
	for (int i = 0; i < l; ++i) {
		f *= f;
	}

	return f;
}

export function assignSwizzleToFunctionArgument(float4 p) -> float4 {
        p.xz = float2(5, 6);
        return p;
}

function CreateFloat4 (float2 a, float b) -> float4
{
	return float4(a, b, 1);
}

function TransformPoint(float4 p, TransformationMatrices m) -> float4
{
	for (int i = 0; i < 3; ++i) {
		p = m.matrices[i] * p;
	}

	for (uint i = 0; i < 3; ++i) {
		if (m.applyOffset[i]) {
			p += m.offset[i];
		}
	}

	return p;
}

function Transform(TransformInfo info) -> void
{
	for (int i = 0; i < info.pointsToTransform; ++i) {
		outputPositions[i] = TransformPoint (inputPositions[i], info.transforms[i]);
	}
}
